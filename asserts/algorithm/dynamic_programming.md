## 动态规划

### 2: 给定m行n列的网格，有一个机器人从左上角(0, 0)出发，每一步可以向下或者向右走一步，问有多少种不同的方式走到右下角？

![unique paths](/asserts/unique-path.png)

本题属于计数型动态规划，根据动态规划四个组成部分来实现

#### 2.1 确定状态

* 最后一步：无论机器人用何种方式到达右下角，总有最后挪动的一步：向右或向下
* 右下角坐标设为（m-1, n-1)
* 那么前一步机器人一定是在(m-2, n-1)或者(m-1, n-2)

#### 2.2 子问题

* 那么，如果机器人有X种方式从左上角走到（m-2, n-1)，有Y种方式从左上角走到(m-1, n-2)，则机器人有X+Y种方式走到(m-1, n-1)

> 思考：为什么是X+Y，无重复且无遗漏

* 问题转化为，机器人有多少种方式从左上角走到(m-2, n-1)和(m-1, n-2)。
* 原题要求有多少种方式从左上角走到(m-1, n-1)
* 子问题
* 状态：设f[i][j]为机器人有多少种方式从左上角走到(i, j)

#### 2.3 转移方程

* 对于任意一个格子(i, j)，都有f[i][j] = f[i-1][j] + f[i][j-1]
> 其中f[i][j]表示：机器人有多少种方式走到(i, j)
> f[i-1][j]表示：机器人有多少种方式走到(i-1, j)
> f[i][j-1]表示：机器人有多少种方式走到(i, j-1)

#### 2.3 初始条件和边界情况

* 初始条件：f[0][0] = 1,因为机器人只有一种方式到左上角
* 边界情况：i = 0 或j = 0,则前一步只能有一个方向过来 f[i][j] = 1

#### 2.4 计算顺序

* f[0][0] = 1
* 计算第0行：f[0][0], f[0][1], ..., f[0][n-1]
* 计算第1行：f[1][0], f[1][1], ..., f[1][n-1]
* ...
* 计算第m-1行：f[m-1][0],f[m-1][1], ...，f[m-1][n-1]
* 答案是f[m-1][n-1]
* 时间复杂度（计算步数）：0(MN)，空间复杂度（数组大小）：O(MN)

```java
public class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        int i,j;
        for (i = 0; i < m; ++i) { // row: up to down;
            for (j = 0; j < n; ++j) { // column: left to right
                if (i == 0 || j == 0) {
                    f[i][j] = 1;
                    continue;
                }
                f[i][j] = f[i -1][j] + f[i][j - 1];
            }
        }
        return f[m-1][n-1];
    }
}
```

