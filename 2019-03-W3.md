## 基于NodeJS的serverless架构实践

### 一、背景

通过将BFF构建于serverless之上，将以往数十个平台应用整合到了一个统一入口。通过云函数的方式取代了传统基于NodeJS的BFF层，实现了在一个站点下不同应用以及不同环境的快速切换。从而极大程度的降低了开发成本和运维成本，使机器数量从上百台缩减为十几台，同时有效减少了业务方的学习和理解成本。

本文主要讲述了BFF局限性以及我们对应的serverless解决方案，其中平台核心功能包括：

* 云函数：将BFF层的Node应用代码拆解成独立云函数，支持动态编写、秒级部署，平台提供隔离的沙箱容器进行执行，并自动接入日志和监控系统，使开发者可实时掌握函数的运行状况；

* 应用：将各平台的前端代码打包部署，入口路由进行统一注册，我们将这些平台称为应用。这些应用将直接支持各环境切换及多套预发环境解决方案；

* SDK：框架将中间件封装为BaaS SDK供应用直接调用，提供一套统一的API抹平了Web和Node的差异；

* CLI：提供命令行工具便于开发者可脱离web管理平台，而直接快速进行开发、调试和发布。

### 二、BFF的局限

从传统大型机到服务器集群，从虚拟技术到容器化，我们正在走向那些更加轻量、更俱灵活性的解决方案。

在行业“大中台，小前台”的大背景下，也逐渐从巨石应用拆分成更为灵活的微服务，以便以更小的粒度服务于更多的需求方。

而前端也在以往前后端分离的基础上，更进一步的演变为了BFF架构。根据最终端上的需求，通过BFF层将各个微服务进行聚合和裁剪后返回。根据“谁受益谁负责”原则，该BFF层通常由前端使用NodeJS维护。

![典型的BFF架构](/asserts/BFF-struct.png)

然而，作为横向支撑的前端团队，我们在实施BFF架构之后，却发现它可能并没有想象的那么美好。截止到目前，已经形成20几个平台，对于大量平台的存在，对开发人员的维护和业务方的理解，都成为了一种负担。

* 首先，每个平台都有一个对应的Node层来作为BFF，我们仍然需要针对每一个平台部署代码、安装依赖的各种软件，关心究竟需要多少台服务器，这极大的增加了我们的运维成本；

* 其次，由于各个平台十分分散，均由独立域名进行访问，不同团队可能并不清楚已经存在一个类似平台从而导致提出相似需求，并且各个平台对于账户、权限、文件上传等中间件都需进行接入，对开发资源造成严重浪费；

* 最后，作为业务方，需要记住大量不同平台域名和对应的功能，也成为了一项挑战。而每个平台还有对应多套环境，也增加了他们的沟通成本和使用成本。

![BFF层横向扩展带来的挑战](/asserts/BFF-struct2.png)

所以，我们核心面临的问题总结起来就是运维成本难降低、重复开发难避免、入口分散难管理。那么有没有一种更轻量的架构，使我们所有人能从上述这些繁琐的工作中解放出来？

我们想到了serverless，它让NoOps成为可能，实现零配置发布业务代码，这能极大降低运维成本。但传统的serverless仍然只能解决一个点的问题，如果我们做的更进一步，将serverless与已有的BFF、FE整合，那是不是有可能同时解决上述问题？基于上述考虑，我们提出了自己的serverless架构。

### 三、serverless

![基于AWS lambda的典型应用](/asserts/aws-lambda.png)

serverless的定义如下：

> 无服务架构是基于互联网的系统，其中应用开发不使用常规的服务进程。相反，他们仅依赖于第三方服务，客户端逻辑和服务托管远程过程调用的组合。

目前我们说的serverless，最常是指Amazon在2014年发布的AWS Lambda服务，为在服务端中运行的程序提供了一种全新的架构。我们不需要在服务器上持续运行进程以等待请求，而是可以通过某种事件机制来触发容器从而动态的执行代码。

不需要再关心应该配置多少机器，需要预装哪些依赖，这些统统由平台搞定，而我们只需要维护一个功能的集合，这些功能以“函数”的方式被调用。这种模式我们通常也把它称为Faas（Function as a Services），一种比微服务更小的代码组织方式。

### 四、BFF in serverless

然而独立的Faas其实并不具备实用性，因为它是无状态的，无法进行存储意味着无法针对不同用户提供服务。Amazon的解决方案是让Lambda打通AWS大量基础服务，通过简单的API调用，即可使用S3、RDS等存储服务来保存用户数据。即使这样，仍然有很多工作需要开发者完成。

结合实际情况，在平台中统一了FE、BFF，并封装了常用的中间件，使其成为一体化解决方案，让开发者仅需在一个平台，即可完成应用的开发、调试、构建和部署。

![平台整体链路](/asserts/BFF-struct3-new.png)

#### 4.1 云函数

函数运行可以说是serverless架构的基础，为此采用创建了一个独立的sandbox模块来提供该功能的基础环境。

其实现方式类似egg的master/worker模式。不同之处在于请求进来时，会根据request查询到具体的代码片段，然后启动worker进程来运行，最后将运行的结果response到客户端，workder再进行自销毁。

这么做的好处是可以针对任何一个函数进行监控和限制，了解和控制它的运行时长、内存占用，防止恶意代码侵害公共环境，不同函数之间也不会造成相互影响。如下图

![函数运行环境](/asserts/cloud-Function.png)

关于worker进程层级的设计如下图：

![沙箱worker层级](/asserts/sandbox-worker.png)

todo：sandbox worker需要变成一个pool，便于负载均衡

#### 4.2 开发者工作台（应用）

维护一个统一的入口，是平台其他功能能正常运转的基石。通过系统发布的所有平台，均通过同一域名进入，在导航处提供了在不同平台之间切换的功能，我们将这些平台称为“应用”。

这里特意说明下，一般门户，在导航至不同的二级域名，其每个二级站点实际为独立机器进行部署，而我们采用在不同应用之前切换，只是同一域名下不同路由的切换，实际背后提供的服务都是同一个服务器集群。

这样做的好处是一些业务无关的框架级功能可以在平台上进行统一实现，比如后面提到的环境切换和多套预发环境管理。对于业务来说，需要方再也不需要记住不同平台的各种域名。

而开发者工作台，提供了应用管理的所有功能，包括Baas配置、函数发布、监控日志等，以满足开发者的日常需求，并极大的改善开发者开发体验。

![开发者平台](/asserts/dev-center.png)

#### 4.3 在线环境切换

利用统一入口的优势，我们可以在日常、预发、线上之间实现无缝切换。然而由于日常与线上的天然隔离，以及环境限制，我们并没有办法在线上环境的函数中，调用日常环境的接口。为了实现各环境互通，我们在统一入口处增加了一层线上环境Proxy。通过这层Proxy，线上环境仍是正常访问，而当访问的是预发、日常的函数时，将通过HTTP的方式，到真正平台对应环境的机器上再执行相应函数。

#### 4.4 多套预发环境管理

#### 4.5 BaaS SDK

#### 4.6 CLI工具

### 五、后续规划

### 六、结尾